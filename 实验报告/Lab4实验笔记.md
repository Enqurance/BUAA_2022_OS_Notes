# Lab4实验笔记

## O、前记

​		lab4的主要内容是**系统调用与fork**。在此之前大致浏览了一下本次实验指导书的内容，应当是以文字阅读和理解为主要内容，故而本次笔记也会有一些这方面的特色。

​		理论上来讲，硬件操作、动态内存分配等操作是被内核认定为比较"危险"的行为，这一类行为放任用户使用可能会造成不可预知的后果，故而它们只能交给内核执行；然而有些用户进程又不可避免地要使用这些操作。故而操作系统会给用户提供"接口"，使得用户能够以安全的方式调用这些内核功能。这就是**系统调用**的初级理解。

​		借用指导书内容，本次实验的主要任务如下：

- 掌握系统调用的概念及流程
- 实现进程间的通讯机制
- 实现进程创建机制`fork()`函数
- 掌握页写入异常的处理流程

## 一、系统调用

### 1.概念回忆

​		首先进行概念的整理，便于后面的学习解释。

|     概念名词      |                             解释                             |
| :---------------: | :----------------------------------------------------------: |
|   内核态/用户态   | CPU运行的两种模式，拥有不同级别的权限。该状态由 CP0协处理器的SR 寄存器中KUc位的值标志 |
| 内核空间/用户空间 | 进程的虚拟地址的两部分（在同一进程中存在）。在虚拟地址映射中，用户空间的虚拟页通过页表映射到物理页，内核空间的虚拟页则映射到固定的物理页和外部设备。CPU在内核态下，才可以访问进程的内核空间。 |
|     进程/内核     | 进程是资源分配和调度的基本单位，内核负责管理和分配系统资源。内核的调度功能决定了它可以和进程共存。 |

​		在lab3中，我们的进程是运行在内核态下的。为了使进程运行在用户态下，我们需要通过某种办法修改CP0中SR寄存器的值（还记得吗？SR低六位寄存器是作为一个二重栈使用的）。我们通过修改`Trapframe`结构体中的值保证进入中断时写入该寄存器的值正确。`exercise 4.0`就是要求在创建进程时向`env_tf.cp0_status`写入0x1000100c。

### 2.系统调用溯源

​		在指导书中，举了一个调用`puts()`函数的例子，来为我们揭示了系统调用的本源。我们知道，标准IO操作必须在中断下进行（也就是内核态），这一过程中就使用到了系统调用。指导书通过一系列汇编、反汇编以及调试操作实现了溯源过程，整理出调用`puts()`函数发挥作用的全过程：

- 调用`puts()`的下层函数`write()`
- `write()`函数为寄存器设定了相应的值，并执行`syscall`
- 系统进入内核态，根据设定的值运行发挥作用
- 返回`write()`函数，取出寄存器值，继续返回直至`puts()`函数

​		这其中有些操作，和我们在组成原理的P7部分完成的工作很是相似（当然，有的同学没有接触P7，指导书需要照顾这些同学所以要写的详细）。我们可以通过这一过程了解到：

- IO操作需要内核来完成，即需要系统进入内核态（当然，不仅仅是IO操作）
- syscall指令可以使系统陷入内核态（在Mars中我们都是用过这个指令）
- 系统状态切换时，需要进行数据保护

​		当今，用户已经很少直接使用系统调用了。很多语言都已经帮我们封装好了一些底层的操作~~，不要重复造轮子~~。

### 3.实现系统调用

​		系统调用也是一种中断，我们在lab3中已经介绍过中断处理流程。异常向量组分发的8号异常就是专门处理这一中断的。指导书指出，我们将在`./user/printf.c`函数中学习相关流程。

```C
static void user_myoutput(void *arg, const char *s, int l)
{
	int i;

	// special termination call
	if ((l == 1) && (s[0] == '\0')) {
		return;
	}

	for (i = 0; i < l; i++) {
		syscall_putchar(s[i]);

		if (s[i] == '\n') {
			syscall_putchar('\n');
		}
	}
}

void writef(char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	user_lp_Print(user_myoutput, 0, fmt, ap);
	va_end(ap);
}
```

​		其中的`user_lp_Print()`函数用于输出字符串，它调用了`user_myoutput()`函数；`use_myoutput()`函数又调用了`syscall_putchar()`函数；`syscall_putchar()`函数又调用了`msyscall()`。如果你使用ctag，你就会发现，到此就是调用的终点了，因为`msyscall`就是一个汇编函数，系统在此进入了内核态。结束函数的执行后，会一层层向上返回。

​		如果你细心的话，你会发现在`syscall_putchar()`同文件下，还有很多长相相似的函数，如`syscall_yield()`、`syscall_env_destory()`等。这些函数都会调用`msyscall()`函数，由他们的名字可以知道它们是何种中断触发的系统调用。

​		`msyscall()`传入了六个参数，第一个通常是和本函数对应中断问题相关的宏，学名为系统调用号。剩余的参数随着功能而改变。`msyscall()`传递参数的方法，和组成原理课程中的栈帧操作一样：函数调用时，将当前层函数的内容压栈（通过移动栈指针实现），供下一层函数使用；返回时则推栈（也是移动栈指针）。在`msyscall()`中，我们有六个参数，其中四个可以通过寄存器堆约定俗成的`$a0~$a4`寄存器传递，剩下的要通过栈来传递；不过，在压栈时，我们也会为前四个参数预留栈空间（不写入）。

​		上面都是一些原理性的内容，我们接下来需要在`exercise4.1`中完成`msyscall()`函数。这样的简单操作，我们在上学期已经做的够多了。

```
LEAF(msyscall)
    syscall
    jr  ra
    nop
END(msyscall)
```

​		接下来，我们要实现一个`handle_sys`汇编函数。我们上次实现了一个`handle_int`函数用于处理时钟中断，这个函数则是用于处理系统调用中断。这一函数中，我第一次填写的时候尚且有很多地方没能完全弄明白，故而先摘取指导书中的一些解释，后续还会补充我的理解。

```C
NESTED(handle_sys,TF_SIZE, sp)
    SAVE_ALL                            /* 用于保存所有寄存器的汇编宏 */
    CLI                                 /* 用于屏蔽中断位的设置的汇编宏 */
    nop
    .set at                             /* 恢复$at寄存器的使用 */
  /* 取出Trapframe的EPC寄存器的值，将其修改为下一条指令的值并写回。由于之前Trapframe结构体已经使用汇编宏保存，此处也只需要使用汇编指令存取 */
	lw		t0, TF_EPC(sp)
	addiu	t0, t0, 4
	sw		t0, TF_EPC(sp)
  /* 将系统调用号存入a0寄存器 */
	lw		ao, TF_REG4(sp)
    addiu   a0, a0, -__SYSCALL_BASE     /* a0 <- “相对”系统调用号 */
    sll     t0, a0, 2                   /* t0 <- 相对系统调用号 * 4 */
    la      t1, sys_call_table          /* t1 <- 系统调用函数的入口表基地址 */
    addu    t1, t1, t0                  /* t1 <- 特定系统调用函数入口表项地址 */
    lw      t2, 0(t1)                   /* t2 <- 特定系统调用函数入口函数地址 */

    lw      t0, TF_REG29(sp)            /* t0 <- 用户态的栈指针 */
    lw      t3, 16(t0)                  /* t3 <- msyscall的第5个参数 */
    lw      t4, 20(t0)                  /* t4 <- msyscall的第6个参数 */
    /* 使用栈指针为六个参数分配空间，并将参数写入正确的位置 */
	lw		a0, TF_REG4(sp)
	lw		a1, TF_REG5(sp)
	lw		a2, TF_REG6(sp)
	lw		a3, TF_REG7(sp)
  /* 栈向下增长，并且将第五个和第六个参数写入寄存器，传入下一层函数；其余的参数通过参数寄存器传递 */
	addiu	sp, sp, -24
	sw		t3, 16(sp)
	sw		t4, 20(sp)

    jalr    t2                          // Invoke sys_* function
    nop

  /* 恢复栈指针 */
	addiu	sp,	sp,	24
    sw      v0, TF_REG2(sp)            /* 将$v0中的sys_*函数返回值存入Trapframe */
    j       ret_from_exception          /* 从异常中返回（恢复现场） */
    nop
END(handle_sys)
```

