# 林子杰\_20373980\_lab2

## 一、思考题

### Thinking 2.1

​		我们编写的程序（如C、C++）等，指针变量使用的地址是虚拟地址。

​		我们编写的MIPS汇编程序，lw、sw等指令使用的是虚拟地址。

​		对于我们课程设计所使用的CPU，也是存在虚拟地址到物理地址的映射的。在课程网站上有kesg0、kseg1等虚拟地址段的映射方法，在此不赘述。

### Thinking 2.2

​		通过宏编写链表定义以及操作函数，不仅能够以库的形式在多个文件中实现复用，还可以看见，根据宏定义的特性，能够方便地根据类型定义链表，创建含有不同对象的链表，而不需要在每次想使用新的链表时进行重新定义。这都提高了代码的复用性。

​		至于实验环境中的"单向链表"与"循环链表"的实现，我在文件中好像并没有发现，于是自己上网查询了一下资料。首先，我发现我们使用的链表，用更加专业的术语来称呼应该是"双向无尾链表"。另外两种链表应该指的是"单向无尾链表"与"循环链表队列"。

- 单向无尾链表：单向无尾链表和我们平时接触的单向链表几乎一样，存在一个头节点，后面尾随着一个一个节点。单向无尾链表在每次插入删除时都需要遍历，适合作为堆栈使用
- 双向无尾链表：即我们使用的链表，在插入删除时，只需要了解其前驱或后驱节点即可插入删除，而不需要遍历。不过其ELF格式文件的大小、时空性能都会比单向无尾链表稍差。
- 循环链表队列：头尾相接的单向链表。其插入删除也需要进行查询，不过头尾相接的特性会有利于某些数据的存储和查询。其时空开销也比单向无尾链表大。

### Thinking 2.3

​		对照文件里定义的宏、在草稿纸上一步一步展开，其实不难得到结果，就是有些绕。展开如下：

```C
struct Page_list{
    struct {
        struct {
            struct Page *le_next;
            struct Page **le_prev;
        } pp_link;
        u_short pp_ref;
    }* lh_first;
}
```

### Thinking 2.4

​		`boot_map_segment()`函数在`mips_vm_init()`中被调用，后者的功能之一是建立二级页表映射机制，它通过下面这种方法调用了前者。

```C
/* pgdir是一级页表的基地址，将[UPAGES,UPAGES+n)字节的虚拟地址
与[pages,pages+n)的物理地址建立映射关系，并且赋予权限PTE_R */
boot_map_segment(pgdir, UPAGES, n, PADDR(pages), PTE_R);
```

​		`boot_pgdir_walk()`函数在`boot_map_segment()`函数中被调用，前者可以返回虚拟地址对应的二级页表项的地址，后者通过修改这个地址的内容，即可达到映射的效果。

### Thinking 2.5

​		我们知道，TLB根据虚拟地址直接查找其中存储的页表，倘若有匹配，则不会再去多次访问内存了。但是这样可能会引发数据不安全的问题，因为可能会出现这样的情况：不同的进程，其相同的虚拟地址，映射到的物理页不同。显然，在这种情况下，一旦发生了进程切换且新的进程需要访问一个已存在于TLB的虚拟地址时，新的进程会得到错误的物理页面。为了解决这个问题，针对不同的进程，我们提供一个**ASID标识码**，来确保虚拟页查找时的进程专一性。

​		查询《IDT R30xx Family Software Reference Manual》后，得知ASID占据了EntryHi寄存器的6～11位共6位，故而R3000可容纳最大64个不同的地址空间。

### Thinking 2.6

​		查阅代码可知，`tlb_invalidate()`函数调用了`tlb_out()`,且进行了两次调用。两次调用的区别是是否将传入的地址进行了ASID码标记。

​		`tlb_invalidate()`的作用是：在保证对进程的跟踪下更新tlb。

​		下面对`tlb_out`中的汇编代码进行解释。

```C
/* Exercise 2.10 */
LEAF(tlb_out)
//1: j 1b
nop
    /* 将CP0中EntryHi寄存器的内容写入k1 */
	mfc0	k1,CP0_ENTRYHI		
    /* 将a0写入EntryHi寄存器，a0是一个虚拟地址 */
	mtc0	a0,CP0_ENTRYHI		
    /* nop为延迟操指令 */
	nop							
	/* 根据 EntryHi中的Key查找tlb中与之对应的表项，并将表项的索引存入Index寄存器；若未找到匹配项，则 	Index寄存器最高位被置1。 */
	tlbp						
	nop
	nop
	nop
	nop
    /* 将Index寄存器的值写入k0寄存器 */
	mfc0	k0,CP0_INDEX
    /* 判断是否找到tlb表项。若未找到，k0最高位为1，小于零，直接跳转到NOFOUND标签 */
	bltz	k0,NOFOUND
	nop
    /* 找到，则将EntryHi和EntryLo寄存器都清空 */
	mtc0	zero,CP0_ENTRYHI
	mtc0	zero,CP0_ENTRYLO0
	nop
    /* 以Index寄存器中的索引为目标，将上面两个寄存器的内容写入该索引对应的表项 */
	tlbwi
NOFOUND:
	/* 不论如何，恢复现场 */
	mtc0	k1,CP0_ENTRYHI
	/* 跳转回去 */
	j	ra
	nop
END(tlb_out)
```

