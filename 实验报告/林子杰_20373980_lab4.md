# 林子杰\_20373980\_lab4

## 一、思考题

### Thinking 4.1

- 保存现场时，内核会使用一个汇编宏函数`SAVE_ALL`，将相关通用寄存器的值保存到栈帧中。
- 可以，寄存器的值未被改动。
- 通过寄存器传递了四个参数，通过栈帧传递了了两个参数至函数的位置。
- 修改了`Trapframe`中`EPC`的值为下一条指令的地址，确保指令执行正确。

### Thinking 4.2

​		0在MOS中用于表示当前进程，是为`curenv`专门保留的一个位置。在**系统调用**和**IPC**两部分中，很多函数都传入了`envid`；除此之外，我们要注意到，在我们使用系统调用时，很多情况下都是在一个进程和内核之间进行往返。为了便于识别进程，保留一个0用于表示当前进程是很方便的。在`envid2env()`函数中，识别到`envid`为0就直接得到`curenv`，毋需再从数组中存取。

### Thinking 4.3

​		子进程仅执行了fork函数后的代码，没有执行fork函数前的代码，可以猜测子进程可能和父进程共享代码段，也可以猜测子进程在被系统调用创建后，系统调用令子进程回到了fork函数结束的位置，继续执行代码。

### Thinking 4.4

​		关于 fork 函数的两个返回值，下面说法正确的是：

​		**C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值**

​		在这一部分中，我们有很多函数需要填写。我会首先独立地介绍每个函数的功能，随后将会归纳总结他们之间的调用关系。

### Thinking 4.5

​		用户空间的大部分区域都需要进行映射，内核空间则不需要。对于每个分区，我们进行如下分析：

- `UTOP`到`ULIM`的区域存储了`envs`数组、`pages`数组等关键信息，这一部分可以被访问，但是不可被修改，其已经被保护好，不需要在再进行保护。
- `USTACKTOP`到`UTOP`的区域为`Invalid memory`和用户异常栈，不能设置写时保护。

​		`USTACKTOP`以下的页面都是需要进行写时保护的。

### Thinking 4.6

​		vpt为二级页表的起始地址（所有的二级页表的起始），vpd为一级页表的起始地址。我们来一步一步地追溯它们的本源。

​		首先，我们可以在`mmu.h`中找到他们被定义为数组的地方:

```C
typedef u_long Pde;
typedef u_long Pte;

extern volatile Pte* vpt[];
extern volatile Pde* vpd[];
```

​		可见，这两个变量的本质都是`u_long`类型的指针，指向改类型的数组。那么他们的值在哪里被定义呢？我们来到`entry.S`中，发现这个汇编文件中，定义了`vpt`和`vpd`这两个宏。其中，`vpt`为一个字，其中填充了`UVPT`；而`vpd`则要复杂一些，它所对应的字中填充了` (UVPT+(UVPT>>12)*4)`。咋一看是否有点眼熟？这时候我们会发现，兜兜转转又回到了`mmu.h`中，我们可以在内存地图上看到`UVPT`的地址，就是`0x7fc00000`，也就是二级页表的起始地址。到这里，这两个变量的意义就已经明晰了。

​		由于这两者根据其存放在内存中的位置实现了内存自映射机制，故而我们的进程可以通过访问内存来访问一级页表，进而访问二级页表，进而访问其自身的整个页表。

​		二级页表的起始位置在`0x7fc00000`，这个位置往上4KB的内存空间对应的是`(UVPT>>12)`的虚拟页面。要实现自映射机制，一级页表的起始位置应当在二级页表中，且我们知道一级页表中的第一个32位数应当能拿取到第一个二级页表所在页的虚拟地址，而二级页表的第一个32位数则能取到所有页中的第一个页，故而一级页表的第一个32位数应当相对`UVPT`发生偏移，需要偏移`(UVPT>>12)`个bit即`(UVPT>>12)*4)`个字节。

​		用户进程无法修改页表项。

### Thinking 4.7

​		首先，我查询了一下"中断重入"这一概念的意思，得到的结论大致是：中断的时候发生了中断。我大致讲一下我的理解。对于我们的MOS操作系统来说，页写入异常和缺页异常是两种不同的TLB异常。当我们想从TLB中调取页面但是发生中断的时候，我们就会进入内存或者磁盘寻找页面并且将其调入TLB。倘若我们遇到了一种更糟糕的情况：进程出发了页写入异常，我们不得不进入中断并且为其分配页面；然而我们分配的页面不在TLB中，上一个中断却还没有服务完，操作系统不得不再进入一层中断。这应该是可能发生"中断重入"的原因，归纳地来讲，就是连续的重叠的中断所致。

​		MOS实现的是微内核，它将缺页异常的主要部分置于用户态下处理。用户需要依靠Trapframe的信息执行中断处理和恢复现场，故而我们将其保存在用户的"异常处理栈"中

### Thinking 4.8

​		在用户态处理页写入异常符合微内核的设计理念，能够精简内核大小，同时也使该异常处理起来更加方便，性能更好。

​		第二问不是很理解题目的意思。从寄存器的使用方式来讲，在用户态可能发生指令跳转的情况时，将寄存器的内容依照栈指针寄存器sp的目标依次压入栈中，最后再跳转；恢复现场时，先取出sp寄存器的值，并依照其重定位恢复寄存器的值，最后再跳转。这样使用可以保证栈指针的安全性，从而使得通用寄存器在栈中有安全的备份。标准操作可参见`entry.S`中的汇编函数。

### Thinking 4.9

​		父进程在调用系统调用创建子进程的时候，可能会提前出现缺页中断，需要设置缺页处理条件。

​		父进程会给`__pgfault_handler`变量赋值时，会触发缺页中断。由于没有提前配置中断处理，无法处理这样的缺页中断。

​		不需要，子进程与父进程共享这个值。

## 二、实验难点